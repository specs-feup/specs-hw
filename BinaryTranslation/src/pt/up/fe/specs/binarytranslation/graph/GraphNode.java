/**
 * Copyright 2021 SPeCS.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License. under the License.
 */
 
package pt.up.fe.specs.binarytranslation.graph;

import java.util.ArrayList;
import java.util.List;

import com.google.gson.annotations.Expose;

import pt.up.fe.specs.binarytranslation.graph.edge.GraphEdge;
import pt.up.fe.specs.binarytranslation.graph.edge.GraphInput;
import pt.up.fe.specs.binarytranslation.graph.edge.GraphOutput;
import pt.up.fe.specs.binarytranslation.instruction.Instruction;
import pt.up.fe.specs.binarytranslation.instruction.operand.Operand;

public class GraphNode {

    @Expose
    private int nodenr;

    @Expose
    private int level;

    @Expose
    private final Instruction inst;

    // These two lists are generated by converting the
    // Operand list in the "inst" reference into graphinputs/outputs.
    // The inst variable retains the original information for whatever lookup is required
    private List<GraphInput> inputs;
    private List<GraphOutput> outputs;

    // assigns IDs to nodes as they are instantiated?
    // private static int nodecounter = 0;
    // TODO: this doesnt work properly currently (since counting carries over multiple graphs), but will do if some of
    // this code is moved to a BinarySegmentGraph generator

    public GraphNode(Instruction i) {

        // this.op = new GraphOperation(GraphNodeCatalogue.convertInstruction(i));
        this.inst = i;
        this.nodenr = -1;

        // set first level as 0
        this.level = 0;

        // convert operations in instruction to node inputs/outputs
        this.inputs = new ArrayList<GraphInput>();
        this.outputs = new ArrayList<GraphOutput>();

        for (Operand op : i.getData().getOperands()) {
            if (op.isRead())
                this.inputs.add(new GraphInput(op));

            else if (op.isWrite())
                this.outputs.add(new GraphOutput(op));
        }
    }

    // should only need to call this once
    public void setNodenr(int nodenr) {
        this.nodenr = nodenr;
    }

    public Instruction getInst() {
        return inst;
    }

    public List<GraphInput> getInputs() {
        return inputs;
    }

    public List<GraphOutput> getOutputs() {
        return outputs;
    }

    /*
     * Concatenated list of both getInputs and getOutputs
     */
    public List<GraphEdge> getEdges() {
        var list = new ArrayList<GraphEdge>();
        list.addAll(this.getInputs());
        list.addAll(this.getOutputs());
        return list;
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    /*
    public int getNumchildren() {
        return numchildren;
    }
    
    public int getNumparents() {
        return numparents;
    }
    */
    public int getNodeNr() {
        return nodenr;
    }

    public String getRepresentation() {
        return Integer.toString(this.nodenr) + ":" + this.inst.getName();
    }

    public String rawDotty() {
        String ret = "";

        for (GraphInput in : this.inputs) {
            ret += "\t\"" + in.rawDotty() + "\" -> \"" + this.getRepresentation() + "\";\n";
        }

        for (GraphOutput out : this.outputs) {
            if (out.isLiveout())
                ret += "\t\"" + this.getRepresentation() + "\" -> \"" + out.rawDotty() + "\";\n";
        }

        return ret;
    }
}
