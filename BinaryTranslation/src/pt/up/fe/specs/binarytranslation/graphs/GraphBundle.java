/**
 * Copyright 2020 SPeCS.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License. under the License.
 */

package pt.up.fe.specs.binarytranslation.graphs;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.function.Predicate;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.Expose;

import pt.up.fe.specs.binarytranslation.asm.Application;
import pt.up.fe.specs.binarytranslation.binarysegments.BinarySegment;
import pt.up.fe.specs.binarytranslation.binarysegments.detection.SegmentBundle;
import pt.up.fe.specs.binarytranslation.utils.BinaryTranslationUtils;

/**
 * This class represents a group of @BinarySegmentGraph objects, which have been generated by translating a list
 * of @BinarySegment (possibly contained within a @SegmentBundle
 * 
 * @author Nuno
 *
 */
public class GraphBundle implements Serializable {

    /**
     * 
     */
    private static final long serialVersionUID = -2613588543628494399L;

    // TODO: generate a graph bundle from a segment bundle, but add the ability to do so
    // with predication

    @Expose
    private final Date date;

    @Expose
    private final Application appinfo;

    private final List<BinarySegmentGraph> graphs;

    private GraphBundle(ArrayList<BinarySegmentGraph> graphs, Application appinfo) {
        this.graphs = graphs;
        this.appinfo = appinfo;
        this.date = new Date(System.currentTimeMillis());
    }

    /*
     * Returns average ideal instructions per clock cycle
     */
    public float getAverageIPC() {
        return getAverageIPC(null);
    }

    /*
     * Returns average ideal instructions per clock cycle, with predication
     */
    public float getAverageIPC(Predicate<BinarySegmentGraph> predicate) {
        float avg = 0;
        if (predicate != null)
            for (BinarySegmentGraph seg : this.graphs) {
                if (predicate.test(seg))
                    avg += seg.getEstimatedIPC();
            }
        else
            for (BinarySegmentGraph seg : this.graphs) {
                avg += seg.getEstimatedIPC();
            }
        return avg /= this.graphs.size();
    }

    private String getOutputFolder() {
        return "./graphbundle_" + this.hashCode();
    }

    /*
     * Generate output for a set (or all) graphs
     */
    public void generateOutput() {
        generateOutput(getOutputFolder(), null);
    }

    public void generateOutput(String outputfolder) {
        generateOutput(outputfolder, null);
    }

    public void generateOutput(Predicate<BinarySegmentGraph> predicate) {
        generateOutput(getOutputFolder(), predicate);
    }

    /*
     * Return full path for JSON file
     */
    private String getJSONPathname() {
        return getOutputFolder() + "/bundle_" + this.hashCode() + ".json";
    }

    public void generateOutput(String outputfolder, Predicate<BinarySegmentGraph> predicate) {

        // top level JSON info
        Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting().create();
        var bytes = gson.toJson(this).getBytes();
        BinaryTranslationUtils.bytesToFile(getJSONPathname(), bytes);

        // TODO: does it make sense to have the top level jSON info here, due to the predicates that only
        // apply to individual graphs?...

        if (predicate == null)
            for (BinarySegmentGraph seg : this.graphs) {
                seg.generateOutput(outputfolder);
            }
        else
            for (BinarySegmentGraph seg : this.graphs) {
                if (predicate.test(seg))
                    seg.generateOutput(outputfolder);
            }
    }

    public Date getDate() {
        return date;
    }

    public Application getAppinfo() {
        return appinfo;
    }

    public List<BinarySegmentGraph> getGraphs() {
        return graphs;
    }

    /*
     * Get json bytes
     */
    public byte[] toJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(this).getBytes();
    }

    /*
     * Returns graphs based on any given predicate applied over a single BinarySegmentGraph
     */
    public List<BinarySegmentGraph> getGraphs(Predicate<BinarySegmentGraph> predicate) {

        var list = new ArrayList<BinarySegmentGraph>();
        for (var seg : this.graphs) {
            if (predicate.test(seg))
                list.add(seg);
        }
        return list;
    }

    /*
     * Returns average ideal instructions per clock cycle, 
     * weighed by the number of occurrences of each segment
     */
    /*public int getWeigthedAverageIPC() {
    
    }*/

    /*
     * Static "constructor" creates a new GraphBundle from a SegmentBundle
     */
    public static GraphBundle newInstance(SegmentBundle bund) {
        var graphs = new ArrayList<BinarySegmentGraph>();
        for (BinarySegment seg : bund.getSegments()) {
            graphs.add(BinarySegmentGraph.newInstance(seg));
        }

        return new GraphBundle(graphs, bund.getApplicationInformation());
    }

    /*
     * Static "constructor" creates a new GraphBundle from a single BinarySegment
     */
    public static GraphBundle newInstance(BinarySegment seg) {
        var graphs = new ArrayList<BinarySegmentGraph>();
        graphs.add(BinarySegmentGraph.newInstance(seg));
        return new GraphBundle(graphs, seg.getAppinfo());
    }

    /*
     * Static "constructor" creates a new GraphBundle from a list of SegmentBundle
     */
    public static GraphBundle newInstance(List<BinarySegment> segs) {
        var graphs = new ArrayList<BinarySegmentGraph>();
        for (BinarySegment seg : segs) {
            graphs.add(BinarySegmentGraph.newInstance(seg));
        }

        return new GraphBundle(graphs, segs.get(0).getAppinfo());
    }
}
