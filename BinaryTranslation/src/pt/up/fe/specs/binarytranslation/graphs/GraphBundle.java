/**
 * Copyright 2020 SPeCS.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License. under the License.
 */

package pt.up.fe.specs.binarytranslation.graphs;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.function.Predicate;

import com.google.gson.annotations.Expose;

import pt.up.fe.specs.binarytranslation.BinaryTranslationOutput;
import pt.up.fe.specs.binarytranslation.asm.Application;
import pt.up.fe.specs.binarytranslation.binarysegments.BinarySegment;
import pt.up.fe.specs.binarytranslation.binarysegments.detection.SegmentBundle;

/**
 * This class represents a group of @BinarySegmentGraph objects, which have been generated by translating a list
 * of @BinarySegment (possibly contained within a @SegmentBundle
 * 
 * @author Nuno
 *
 */
public class GraphBundle implements BinaryTranslationOutput {

    // TODO: generate a graph bundle from a segment bundle, but add the ability to do so
    // with predication

    @Expose
    private final Date date;

    @Expose
    private final Application appinfo;

    private final List<BinarySegmentGraph> graphs;

    private GraphBundle(ArrayList<BinarySegmentGraph> graphs, Application appinfo) {
        this.graphs = graphs;
        this.appinfo = appinfo;
        this.date = new Date(System.currentTimeMillis());
    }

    /*
     * Returns average ideal instructions per clock cycle
     */
    public float getAverageIPC() {
        return getAverageIPC(null);
    }

    /*
     * Returns average ideal instructions per clock cycle, with predication
     */
    public float getAverageIPC(Predicate<BinarySegmentGraph> predicate) {
        float avg = 0;
        if (predicate != null)
            for (BinarySegmentGraph seg : this.graphs) {
                if (predicate.test(seg))
                    avg += seg.getEstimatedIPC();
            }
        else
            for (BinarySegmentGraph seg : this.graphs) {
                avg += seg.getEstimatedIPC();
            }
        return avg /= this.graphs.size();
    }

    /*
     * Generate output for a set (or all) graphs
     */
    @Override
    public void generateOutput() {
        generateOutput(this.getOutputFolder(), null);
    }

    @Override
    public void generateOutput(File parentfolder) {
        generateOutput(parentfolder, null);
    }

    public void generateOutput(Predicate<BinarySegmentGraph> predicate) {
        generateOutput(this.getOutputFolder(), predicate);
    }

    public void generateOutput(File parentfolder, Predicate<BinarySegmentGraph> predicate) {

        var bsgfolder = new File(parentfolder, "bsg");
        bsgfolder.mkdir();
        if (predicate == null)
            for (BinarySegmentGraph seg : this.graphs) {
                seg.generateOutput(new File(bsgfolder, seg.getOutputFolderName()));
            }
        else
            for (BinarySegmentGraph seg : this.graphs) {
                if (predicate.test(seg))
                    seg.generateOutput(new File(bsgfolder, seg.getOutputFolderName()));
            }
    }

    @Override
    public void toJSON(File outputfolder) {

        // first do self
        BinaryTranslationOutput.super.toJSON(outputfolder);

        // then list of segments
        var bsgfolder = new File(outputfolder, "bsg");
        for (var g : this.getGraphs()) {
            g.toJSON(new File(bsgfolder, g.getOutputFolderName()));
        }
    }

    public Date getDate() {
        return date;
    }

    public Application getAppinfo() {
        return appinfo;
    }

    public List<BinarySegmentGraph> getGraphs() {
        return graphs;
    }

    /*
     * Returns graphs based on any given predicate applied over a single BinarySegmentGraph
     */
    public List<BinarySegmentGraph> getGraphs(Predicate<BinarySegmentGraph> predicate) {

        var list = new ArrayList<BinarySegmentGraph>();
        for (var seg : this.graphs) {
            if (predicate.test(seg))
                list.add(seg);
        }
        return list;
    }

    /*
     * Returns average ideal instructions per clock cycle, 
     * weighed by the number of occurrences of each segment
     */
    /*public int getWeigthedAverageIPC() {
    
    }*/

    /*
     * Static "constructor" creates a new GraphBundle from a SegmentBundle
     */
    public static GraphBundle newInstance(SegmentBundle bund) {
        var graphs = new ArrayList<BinarySegmentGraph>();
        for (BinarySegment seg : bund.getSegments()) {
            graphs.add(BinarySegmentGraph.newInstance(seg));
        }

        return new GraphBundle(graphs, bund.getApplicationInformation());
    }

    /*
     * Static "constructor" creates a new GraphBundle from a single BinarySegment
     */
    public static GraphBundle newInstance(BinarySegment seg) {
        var graphs = new ArrayList<BinarySegmentGraph>();
        graphs.add(BinarySegmentGraph.newInstance(seg));
        return new GraphBundle(graphs, seg.getAppinfo());
    }

    /*
     * Static "constructor" creates a new GraphBundle from a list of SegmentBundle
     */
    public static GraphBundle newInstance(List<BinarySegment> segs) {
        var graphs = new ArrayList<BinarySegmentGraph>();
        for (BinarySegment seg : segs) {
            graphs.add(BinarySegmentGraph.newInstance(seg));
        }

        return new GraphBundle(graphs, segs.get(0).getAppinfo());
    }
}
